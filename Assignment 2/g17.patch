Binary files xv6org/a.out and xv6/a.out differ
diff -ruN xv6org/defs.h xv6/defs.h
--- xv6org/defs.h	2020-08-10 23:58:02.000000000 +0530
+++ xv6/defs.h	2020-10-14 12:15:22.711454000 +0530
@@ -9,7 +9,7 @@
 struct sleeplock;
 struct stat;
 struct superblock;
-
+struct processInfo;
 // bio.c
 void            binit(void);
 struct buf*     bread(uint, uint);
@@ -120,7 +120,12 @@
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
-
+int 			getNumProc(void);
+int 			getMaxPid(void);
+int 			getProcInfo(int, struct processInfo*);
+int 			set_burst_time(int);
+int 			get_burst_time(void);
+int 			process_state(void);
 // swtch.S
 void            swtch(struct context**, struct context*);
 
diff -ruN xv6org/ex1.c xv6/ex1.c
--- xv6org/ex1.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6/ex1.c	2020-09-23 19:10:58.000000000 +0530
@@ -0,0 +1,21 @@
+#include <stdio.h>
+int main(int argc, char **argv)
+{
+    int x = 1;
+    printf("Hello x = %d\n", x);
+    //
+    // Put in-line assembly here to increment
+    // the value of x by 1 using in-line assembly
+    //
+    asm("inc %0": "+r"(x));
+    printf("Hello x = %d after increment\n", x);
+
+    if (x == 2)
+    {
+        printf("OK\n");
+    }
+    else
+    {
+        printf("ERROR\n");
+    }
+}
\ No newline at end of file
diff -ruN xv6org/forktest.c xv6/forktest.c
--- xv6org/forktest.c	2020-08-10 23:58:02.000000000 +0530
+++ xv6/forktest.c	2020-10-14 15:36:58.842936000 +0530
@@ -1,12 +1,8 @@
-// Test that fork fails gracefully.
-// Tiny executable so that the limit can be filling the proc table.
-
+// to test fork executes correctly or not
 #include "types.h"
 #include "stat.h"
 #include "user.h"
 
-#define N  1000
-
 void
 printf(int fd, const char *s, ...)
 {
@@ -16,36 +12,41 @@
 void
 forktest(void)
 {
-  int n, pid;
-
-  printf(1, "fork test\n");
-
-  for(n=0; n<N; n++){
+  int n=0, pid;
+  printf(1, "Fork test started\n");
+  while(n<1000)
+  {
     pid = fork();
     if(pid < 0)
       break;
     if(pid == 0)
       exit();
+    n++;
   }
 
-  if(n == N){
-    printf(1, "fork claimed to work N times!\n", N);
+  if(n == 1000)
+  {
+    printf(1, "fork claimed to work 1000 times!\n", 1000);
     exit();
   }
 
-  for(; n > 0; n--){
-    if(wait() < 0){
+  while(n>0)
+  {
+    if(wait() < 0)
+    {
       printf(1, "wait stopped early\n");
       exit();
     }
+    n--;
   }
 
-  if(wait() != -1){
+  if(wait() != -1)
+  {
     printf(1, "wait got too many\n");
     exit();
   }
 
-  printf(1, "fork test OK\n");
+  printf(1, "OK tested.\n");
 }
 
 int
diff -ruN xv6org/.git/config xv6/.git/config
--- xv6org/.git/config	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/config	2020-09-14 14:50:38.000000000 +0530
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = git://github.com/mit-pdos/xv6-public.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -ruN xv6org/.git/description xv6/.git/description
--- xv6org/.git/description	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/description	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -ruN xv6org/.git/HEAD xv6/.git/HEAD
--- xv6org/.git/HEAD	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/HEAD	2020-09-14 14:50:38.000000000 +0530
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -ruN xv6org/.git/hooks/applypatch-msg.sample xv6/.git/hooks/applypatch-msg.sample
--- xv6org/.git/hooks/applypatch-msg.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/applypatch-msg.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+:
diff -ruN xv6org/.git/hooks/commit-msg.sample xv6/.git/hooks/commit-msg.sample
--- xv6org/.git/hooks/commit-msg.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/commit-msg.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -ruN xv6org/.git/hooks/fsmonitor-watchman.sample xv6/.git/hooks/fsmonitor-watchman.sample
--- xv6org/.git/hooks/fsmonitor-watchman.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/fsmonitor-watchman.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,109 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use IPC::Open2;
+
+# An example hook script to integrate Watchman
+# (https://facebook.github.io/watchman/) with git to speed up detecting
+# new and modified files.
+#
+# The hook is passed a version (currently 1) and a time in nanoseconds
+# formatted as a string and outputs to stdout all files that have been
+# modified since the given time. Paths must be relative to the root of
+# the working tree and separated by a single NUL.
+#
+# To enable this hook, rename this file to "query-watchman" and set
+# 'git config core.fsmonitor .git/hooks/query-watchman'
+#
+my ($version, $time) = @ARGV;
+
+# Check the hook interface version
+
+if ($version == 1) {
+	# convert nanoseconds to seconds
+	# subtract one second to make sure watchman will return all changes
+	$time = int ($time / 1000000000) - 1;
+} else {
+	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+	    "Falling back to scanning...\n";
+}
+
+my $git_work_tree;
+if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+	$git_work_tree = Win32::GetCwd();
+	$git_work_tree =~ tr/\\/\//;
+} else {
+	require Cwd;
+	$git_work_tree = Cwd::cwd();
+}
+
+my $retry = 1;
+
+launch_watchman();
+
+sub launch_watchman {
+
+	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+	    or die "open2() failed: $!\n" .
+	    "Falling back to scanning...\n";
+
+	# In the query expression below we're asking for names of files that
+	# changed since $time but were not transient (ie created after
+	# $time but no longer exist).
+	#
+	# To accomplish this, we're using the "since" generator to use the
+	# recency index to select candidate nodes and "fields" to limit the
+	# output to file names only.
+
+	my $query = <<"	END";
+		["query", "$git_work_tree", {
+			"since": $time,
+			"fields": ["name"]
+		}]
+	END
+
+	print CHLD_IN $query;
+	close CHLD_IN;
+	my $response = do {local $/; <CHLD_OUT>};
+
+	die "Watchman: command returned no output.\n" .
+	    "Falling back to scanning...\n" if $response eq "";
+	die "Watchman: command returned invalid output: $response\n" .
+	    "Falling back to scanning...\n" unless $response =~ /^\{/;
+
+	my $json_pkg;
+	eval {
+		require JSON::XS;
+		$json_pkg = "JSON::XS";
+		1;
+	} or do {
+		require JSON::PP;
+		$json_pkg = "JSON::PP";
+	};
+
+	my $o = $json_pkg->new->utf8->decode($response);
+
+	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
+		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
+		$retry--;
+		qx/watchman watch "$git_work_tree"/;
+		die "Failed to make watchman watch '$git_work_tree'.\n" .
+		    "Falling back to scanning...\n" if $? != 0;
+
+		# Watchman will always return all files on the first query so
+		# return the fast "everything is dirty" flag to git and do the
+		# Watchman query just to get it over with now so we won't pay
+		# the cost in git to look up each individual file.
+		print "/\0";
+		eval { launch_watchman() };
+		exit 0;
+	}
+
+	die "Watchman: $o->{error}.\n" .
+	    "Falling back to scanning...\n" if $o->{error};
+
+	binmode STDOUT, ":utf8";
+	local $, = "\0";
+	print @{$o->{files}};
+}
diff -ruN xv6org/.git/hooks/post-update.sample xv6/.git/hooks/post-update.sample
--- xv6org/.git/hooks/post-update.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/post-update.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -ruN xv6org/.git/hooks/pre-applypatch.sample xv6/.git/hooks/pre-applypatch.sample
--- xv6org/.git/hooks/pre-applypatch.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/pre-applypatch.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
+:
diff -ruN xv6org/.git/hooks/pre-commit.sample xv6/.git/hooks/pre-commit.sample
--- xv6org/.git/hooks/pre-commit.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/pre-commit.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=$(git hash-object -t tree /dev/null)
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -ruN xv6org/.git/hooks/pre-merge-commit.sample xv6/.git/hooks/pre-merge-commit.sample
--- xv6org/.git/hooks/pre-merge-commit.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/pre-merge-commit.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,13 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git merge" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message to
+# stderr if it wants to stop the merge commit.
+#
+# To enable this hook, rename this file to "pre-merge-commit".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+        exec "$GIT_DIR/hooks/pre-commit"
+:
diff -ruN xv6org/.git/hooks/prepare-commit-msg.sample xv6/.git/hooks/prepare-commit-msg.sample
--- xv6org/.git/hooks/prepare-commit-msg.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/prepare-commit-msg.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples. The first one removes the
+# "# Please enter the commit message..." help message.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
+
+/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+
+# case "$COMMIT_SOURCE,$SHA1" in
+#  ,|template,)
+#    /usr/bin/perl -i.bak -pe '
+#       print "\n" . `git diff --cached --name-status -r`
+# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+#  *) ;;
+# esac
+
+# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+# if test -z "$COMMIT_SOURCE"
+# then
+#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+# fi
diff -ruN xv6org/.git/hooks/pre-push.sample xv6/.git/hooks/pre-push.sample
--- xv6org/.git/hooks/pre-push.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/pre-push.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo >&2 "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -ruN xv6org/.git/hooks/pre-rebase.sample xv6/.git/hooks/pre-rebase.sample
--- xv6org/.git/hooks/pre-rebase.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/pre-rebase.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up to date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff -ruN xv6org/.git/hooks/pre-receive.sample xv6/.git/hooks/pre-receive.sample
--- xv6org/.git/hooks/pre-receive.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/pre-receive.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to make use of push options.
+# The example simply echoes all push options that start with 'echoback='
+# and rejects all pushes when the "reject" push option is used.
+#
+# To enable this hook, rename this file to "pre-receive".
+
+if test -n "$GIT_PUSH_OPTION_COUNT"
+then
+	i=0
+	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+	do
+		eval "value=\$GIT_PUSH_OPTION_$i"
+		case "$value" in
+		echoback=*)
+			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+			;;
+		reject)
+			exit 1
+		esac
+		i=$((i + 1))
+	done
+fi
diff -ruN xv6org/.git/hooks/update.sample xv6/.git/hooks/update.sample
--- xv6org/.git/hooks/update.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/hooks/update.sample	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to block unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files xv6org/.git/index and xv6/.git/index differ
diff -ruN xv6org/.git/info/exclude xv6/.git/info/exclude
--- xv6org/.git/info/exclude	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/info/exclude	2020-09-14 14:50:30.000000000 +0530
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -ruN xv6org/.git/logs/HEAD xv6/.git/logs/HEAD
--- xv6org/.git/logs/HEAD	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/logs/HEAD	2020-09-14 14:50:38.000000000 +0530
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 kousikr26 <kousik18@iitg.ac.in> 1600075238 +0530	clone: from git://github.com/mit-pdos/xv6-public.git
diff -ruN xv6org/.git/logs/refs/heads/master xv6/.git/logs/refs/heads/master
--- xv6org/.git/logs/refs/heads/master	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/logs/refs/heads/master	2020-09-14 14:50:38.000000000 +0530
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 kousikr26 <kousik18@iitg.ac.in> 1600075238 +0530	clone: from git://github.com/mit-pdos/xv6-public.git
diff -ruN xv6org/.git/logs/refs/remotes/origin/HEAD xv6/.git/logs/refs/remotes/origin/HEAD
--- xv6org/.git/logs/refs/remotes/origin/HEAD	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/logs/refs/remotes/origin/HEAD	2020-09-14 14:50:38.000000000 +0530
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 kousikr26 <kousik18@iitg.ac.in> 1600075238 +0530	clone: from git://github.com/mit-pdos/xv6-public.git
Binary files xv6org/.git/objects/pack/pack-f1097e8f7b49771604867bcfd66ab0fb98ba7afb.idx and xv6/.git/objects/pack/pack-f1097e8f7b49771604867bcfd66ab0fb98ba7afb.idx differ
Binary files xv6org/.git/objects/pack/pack-f1097e8f7b49771604867bcfd66ab0fb98ba7afb.pack and xv6/.git/objects/pack/pack-f1097e8f7b49771604867bcfd66ab0fb98ba7afb.pack differ
diff -ruN xv6org/.git/packed-refs xv6/.git/packed-refs
--- xv6org/.git/packed-refs	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/packed-refs	2020-09-14 14:50:38.000000000 +0530
@@ -0,0 +1,28 @@
+# pack-refs with: peeled fully-peeled sorted 
+eeb7b415dbcb12cc362d0783e41c3d1f44066b17 refs/remotes/origin/master
+af0e851a3a8a7d13bc2f2d596b58500594040892 refs/tags/osdi12-submit
+^8286b58087750e09bac3815219e0382a0bb2b159
+9e698c587b135db17b38a5838976805b9c01e338 refs/tags/symlinks
+05e0b1218dcebe1f40028531b51926df8ae52be0 refs/tags/xv6-2006
+^5cc0bd5ceaf805ab44f851e6a3f1952a29e9d7b7
+42f3c3f7be9717b66ba6e133a113c0f751c53133 refs/tags/xv6-2007
+adcd16c3f7588b4a28d37495f05e94278c9e3a1e refs/tags/xv6-2008
+124fe7e457c0dc9b671c7ffccb56004eb61da4f0 refs/tags/xv6-2010
+5922cdbbcc4fdbd76eec9e0dad9f650e4c86ee99 refs/tags/xv6-rev0
+^5cc0bd5ceaf805ab44f851e6a3f1952a29e9d7b7
+81f31a773dd49b001437eaed3975438585ff9911 refs/tags/xv6-rev1
+^42f3c3f7be9717b66ba6e133a113c0f751c53133
+b818915f793cd20c5d1e24f668534a9d690f3cc8 refs/tags/xv6-rev11
+30dab73b68b816877dc8f78504ceca0808c976eb refs/tags/xv6-rev3
+^074ac7ccd43c08d01a237ce6f14cac10715a51ef
+113005d48f09a4e3939940d72a77bf6973ea8755 refs/tags/xv6-rev4
+^124fe7e457c0dc9b671c7ffccb56004eb61da4f0
+d6aa754494b37e32862b1f78d53deedc53f66a15 refs/tags/xv6-rev5
+^ae603ff5e79bb7b5eea4147425752f33d29fe558
+3e9d6413d331b4c912d55bfac253af1629d4bac9 refs/tags/xv6-rev6
+^e64c661ae8b91bd7e858bb1895bef96e6ac2b4bb
+ccc25c0fac59067d88af52ad9f3b8cee97c3810a refs/tags/xv6-rev7
+^2ae8392a5c203a7b1bc5b8bff5eabc8b5eab8972
+7d6f95e327f1c18570d5dd187e3d92e1aadae2cf refs/tags/xv6-rev8
+^9ba21267e796eb462a657392906e3cbccaedcc99
+5bf3fbee00fb27cb8cb4eca72dcd9fc4c288ed71 refs/tags/xv6-rev9
diff -ruN xv6org/.git/refs/heads/master xv6/.git/refs/heads/master
--- xv6org/.git/refs/heads/master	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/refs/heads/master	2020-09-14 14:50:38.000000000 +0530
@@ -0,0 +1 @@
+eeb7b415dbcb12cc362d0783e41c3d1f44066b17
diff -ruN xv6org/.git/refs/remotes/origin/HEAD xv6/.git/refs/remotes/origin/HEAD
--- xv6org/.git/refs/remotes/origin/HEAD	1970-01-01 05:30:00.000000000 +0530
+++ xv6/.git/refs/remotes/origin/HEAD	2020-09-14 14:50:38.000000000 +0530
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -ruN xv6org/Makefile xv6/Makefile
--- xv6org/Makefile	2020-08-10 23:58:02.000000000 +0530
+++ xv6/Makefile	2020-10-15 15:19:37.519090000 +0530
@@ -51,7 +51,7 @@
 endif
 
 # If the makefile can't find QEMU, specify its path here
-# QEMU = qemu-system-i386
+QEMU = qemu-system-i386
 
 # Try to infer the correct QEMU
 ifndef QEMU
@@ -181,6 +181,13 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_printMaxPid\
+	_printNumProc\
+	_printProcInfo\
+	_testBurstTime\
+	_process_state\
+	_test_scheduler\
+	_test_sched\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +224,7 @@
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -248,11 +255,12 @@
 # check in that version.
 
 EXTRA=\
-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	mkfs.c ulib.c user.h cat.c echo.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c forktest.c printMaxPid.c printNumProc.c printProcInfo.c testBurstTime.c process_state.c test_scheduler.c test_sched\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
+	
 
 dist:
 	rm -rf dist
diff -ruN xv6org/printMaxPid.c xv6/printMaxPid.c
--- xv6org/printMaxPid.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6/printMaxPid.c	2020-10-14 12:48:29.548732000 +0530
@@ -0,0 +1,11 @@
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main()
+{
+	int max_pid = getMaxPid();
+	printf(1 , "Maximum PID(process ID) is: %d \n" , max_pid);
+  	exit();
+}
\ No newline at end of file
diff -ruN xv6org/printNumProc.c xv6/printNumProc.c
--- xv6org/printNumProc.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6/printNumProc.c	2020-10-14 12:49:55.275709000 +0530
@@ -0,0 +1,10 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main()
+{
+  int num = getNumProc();	
+  printf(1 , "Number of active processes(in either state): %d \n" , num);
+  exit();
+}
\ No newline at end of file
diff -ruN xv6org/printProcInfo.c xv6/printProcInfo.c
--- xv6org/printProcInfo.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6/printProcInfo.c	2020-10-14 12:53:40.406908000 +0530
@@ -0,0 +1,20 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "processInfo.h"
+
+int main()
+{
+    int pid=2;                        // choose yourself  
+    struct processInfo pif;
+    int tmp=getProcInfo(pid, &pif);   //stores the info of process in pif
+    if(tmp==-1){
+        printf(1, "No process found, return value %d \n",tmp );            //No Process Found as -1 returned
+    }
+    else{
+        printf(1, "Process Info: \n  Parent PID is: %d \n ", pif.ppid);
+        printf(1, "Size of the process: %d \n", pif.psize);
+        printf(1, "Number of context switches: %d \n", pif.numberContextSwitches);
+    }
+    exit(); 
+}
\ No newline at end of file
diff -ruN xv6org/proc.c xv6/proc.c
--- xv6org/proc.c	2020-08-10 23:58:02.000000000 +0530
+++ xv6/proc.c	2020-10-15 14:30:04.080819000 +0530
@@ -6,8 +6,10 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "processInfo.h"
 
-struct {
+struct
+{
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
@@ -20,32 +22,32 @@
 
 static void wakeup1(void *chan);
 
-void
-pinit(void)
+void pinit(void)
 {
   initlock(&ptable.lock, "ptable");
 }
 
 // Must be called with interrupts disabled
-int
-cpuid() {
-  return mycpu()-cpus;
+int cpuid()
+{
+  return mycpu() - cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
-struct cpu*
+struct cpu *
 mycpu(void)
 {
   int apicid, i;
-  
-  if(readeflags()&FL_IF)
+
+  if (readeflags() & FL_IF)
     panic("mycpu called with interrupts enabled\n");
-  
+
   apicid = lapicid();
   // APIC IDs are not guaranteed to be contiguous. Maybe we should have
   // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
+  for (i = 0; i < ncpu; ++i)
+  {
     if (cpus[i].apicid == apicid)
       return &cpus[i];
   }
@@ -54,8 +56,9 @@
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
-struct proc*
-myproc(void) {
+struct proc *
+myproc(void)
+{
   struct cpu *c;
   struct proc *p;
   pushcli();
@@ -70,7 +73,7 @@
 // If found, change state to EMBRYO and initialize
 // state required to run in the kernel.
 // Otherwise return 0.
-static struct proc*
+static struct proc *
 allocproc(void)
 {
   struct proc *p;
@@ -78,8 +81,8 @@
 
   acquire(&ptable.lock);
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == UNUSED)
       goto found;
 
   release(&ptable.lock);
@@ -88,11 +91,13 @@
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
-
+  p->count_contextswitch = 0;
+  p->burst_time = 0;
   release(&ptable.lock);
 
   // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
+  if ((p->kstack = kalloc()) == 0)
+  {
     p->state = UNUSED;
     return 0;
   }
@@ -100,15 +105,15 @@
 
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
+  p->tf = (struct trapframe *)sp;
 
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
-  *(uint*)sp = (uint)trapret;
+  *(uint *)sp = (uint)trapret;
 
   sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
+  p->context = (struct context *)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
@@ -117,16 +122,15 @@
 
 //PAGEBREAK: 32
 // Set up first user process.
-void
-userinit(void)
+void userinit(void)
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
+
   initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
+  if ((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
   p->sz = PGSIZE;
@@ -137,7 +141,7 @@
   p->tf->ss = p->tf->ds;
   p->tf->eflags = FL_IF;
   p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
+  p->tf->eip = 0; // beginning of initcode.S
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
@@ -155,18 +159,20 @@
 
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
-int
-growproc(int n)
+int growproc(int n)
 {
   uint sz;
   struct proc *curproc = myproc();
 
   sz = curproc->sz;
-  if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  if (n > 0)
+  {
+    if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  }
+  else if (n < 0)
+  {
+    if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
   }
   curproc->sz = sz;
@@ -177,20 +183,21 @@
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
-int
-fork(void)
+int fork(void)
 {
   int i, pid;
   struct proc *np;
   struct proc *curproc = myproc();
 
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if ((np = allocproc()) == 0)
+  {
     return -1;
   }
 
   // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+  if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0)
+  {
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
@@ -203,8 +210,8 @@
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
+  for (i = 0; i < NOFILE; i++)
+    if (curproc->ofile[i])
       np->ofile[i] = filedup(curproc->ofile[i]);
   np->cwd = idup(curproc->cwd);
 
@@ -224,19 +231,20 @@
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void
-exit(void)
+void exit(void)
 {
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
 
-  if(curproc == initproc)
+  if (curproc == initproc)
     panic("init exiting");
 
   // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
+  for (fd = 0; fd < NOFILE; fd++)
+  {
+    if (curproc->ofile[fd])
+    {
       fileclose(curproc->ofile[fd]);
       curproc->ofile[fd] = 0;
     }
@@ -253,10 +261,12 @@
   wakeup1(curproc->parent);
 
   // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->parent == curproc)
+    {
       p->parent = initproc;
-      if(p->state == ZOMBIE)
+      if (p->state == ZOMBIE)
         wakeup1(initproc);
     }
   }
@@ -269,22 +279,24 @@
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(void)
+int wait(void)
 {
   struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
-  
+
   acquire(&ptable.lock);
-  for(;;){
+  for (;;)
+  {
     // Scan through table looking for exited children.
     havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->parent != curproc)
         continue;
       havekids = 1;
-      if(p->state == ZOMBIE){
+      if (p->state == ZOMBIE)
+      {
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
@@ -301,13 +313,14 @@
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
+    if (!havekids || curproc->killed)
+    {
       release(&ptable.lock);
       return -1;
     }
 
     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    sleep(curproc, &ptable.lock); //DOC: wait-sleep
   }
 }
 
@@ -319,39 +332,88 @@
 //  - swtch to start running that process
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
-void
-scheduler(void)
+
+// Default Round robin scheduling
+// void
+// scheduler(void)
+// {
+//   struct proc *p;
+//   struct cpu *c = mycpu();
+//   c->proc = 0;
+
+//   for(;;){
+//     // Enable interrupts on this processor.
+//     sti();
+//     // Loop over process table looking for process to run.
+//     acquire(&ptable.lock);
+//     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+//       if(p->state != RUNNABLE)
+//         continue;
+
+//       (p->count_contextswitch)++;
+//       // Switch to chosen process.  It is the process's job
+//       // to release ptable.lock and then reacquire it
+//       // before jumping back to us.
+//       c->proc = p;
+//       switchuvm(p);
+//       p->state = RUNNING;
+
+//       swtch(&(c->scheduler), p->context);
+//       switchkvm();
+//       // Process is done running for now.
+//       // It should have changed its p->state before coming back.
+//       //(p->count_contextswitch)++;
+//       c->proc = 0;
+//     }
+//     release(&ptable.lock);
+
+//   }
+// }
+
+// Shortest Job First scheduler implementation
+void scheduler(void)
 {
-  struct proc *p;
+  struct proc *p,*lowest_bt,*p1;        //lowest_bt is the process with shortest burst time
   struct cpu *c = mycpu();
   c->proc = 0;
-  
-  for(;;){
+
+  for (;;)
+  {
     // Enable interrupts on this processor.
     sti();
-
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
-
+    lowest_bt= 0;
+    int currentMin = __INT_MAX__; // CPU burst times are between 1 and 20.
+    for (p1 = ptable.proc; p1 < &ptable.proc[NPROC]; p1++)
+    {
+      if (p1->state != RUNNABLE)  continue;
+      if(p1->burst_time < currentMin)
+      {
+        lowest_bt = p1;
+        currentMin = p1->burst_time;
+      }
+      else if(p1->pid < lowest_bt->pid && p1->burst_time == currentMin)
+      {
+        lowest_bt=p1;
+      }
+      
+    }
+    p=lowest_bt;
+    if (p != 0)
+    {
+      (p->count_contextswitch)++;
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
       c->proc = p;
       switchuvm(p);
       p->state = RUNNING;
-
       swtch(&(c->scheduler), p->context);
       switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
       c->proc = 0;
     }
     release(&ptable.lock);
-
   }
 }
 
@@ -362,19 +424,18 @@
 // be proc->intena and proc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void
-sched(void)
+void sched(void)
 {
   int intena;
   struct proc *p = myproc();
 
-  if(!holding(&ptable.lock))
+  if (!holding(&ptable.lock))
     panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
+  if (mycpu()->ncli != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if (p->state == RUNNING)
     panic("sched running");
-  if(readeflags()&FL_IF)
+  if (readeflags() & FL_IF)
     panic("sched interruptible");
   intena = mycpu()->intena;
   swtch(&p->context, mycpu()->scheduler);
@@ -382,10 +443,9 @@
 }
 
 // Give up the CPU for one scheduling round.
-void
-yield(void)
+void yield(void)
 {
-  acquire(&ptable.lock);  //DOC: yieldlock
+  acquire(&ptable.lock); //DOC: yieldlock
   myproc()->state = RUNNABLE;
   sched();
   release(&ptable.lock);
@@ -393,14 +453,14 @@
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
-void
-forkret(void)
+void forkret(void)
 {
   static int first = 1;
   // Still holding ptable.lock from scheduler.
   release(&ptable.lock);
 
-  if (first) {
+  if (first)
+  {
     // Some initialization functions must be run in the context
     // of a regular process (e.g., they call sleep), and thus cannot
     // be run from main().
@@ -414,15 +474,14 @@
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
+void sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
-  if(p == 0)
+
+  if (p == 0)
     panic("sleep");
 
-  if(lk == 0)
+  if (lk == 0)
     panic("sleep without lk");
 
   // Must acquire ptable.lock in order to
@@ -431,8 +490,8 @@
   // guaranteed that we won't miss any wakeup
   // (wakeup runs with ptable.lock locked),
   // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
+  if (lk != &ptable.lock){                        //DOC: sleeplock0
+    acquire(&ptable.lock); //DOC: sleeplock1
     release(lk);
   }
   // Go to sleep.
@@ -445,7 +504,8 @@
   p->chan = 0;
 
   // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
+  if (lk != &ptable.lock)
+  { //DOC: sleeplock2
     release(&ptable.lock);
     acquire(lk);
   }
@@ -459,14 +519,13 @@
 {
   struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == SLEEPING && p->chan == chan)
       p->state = RUNNABLE;
 }
 
 // Wake up all processes sleeping on chan.
-void
-wakeup(void *chan)
+void wakeup(void *chan)
 {
   acquire(&ptable.lock);
   wakeup1(chan);
@@ -476,17 +535,18 @@
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
-int
-kill(int pid)
+int kill(int pid)
 {
   struct proc *p;
 
   acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)
+    {
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if (p->state == SLEEPING)
         p->state = RUNNABLE;
       release(&ptable.lock);
       return 0;
@@ -500,35 +560,125 @@
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
+void procdump(void)
 {
   static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
+      [UNUSED] "unused",
+      [EMBRYO] "embryo",
+      [SLEEPING] "sleep ",
+      [RUNNABLE] "runble",
+      [RUNNING] "run   ",
+      [ZOMBIE] "zombie"};
   int i;
   struct proc *p;
   char *state;
   uint pc[10];
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->state == UNUSED)
       continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
       state = "???";
     cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
+    if (p->state == SLEEPING)
+    {
+      getcallerpcs((uint *)p->context->ebp + 2, pc);
+      for (i = 0; i < 10 && pc[i] != 0; i++)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
   }
 }
+
+int getNumProc(void)
+{
+  struct proc *p;
+  acquire(&ptable.lock);
+  int cnt = 0;        // to count number of processes.
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if(p->state == UNUSED) continue;
+    cnt++;
+  }
+  release(&ptable.lock);
+  return cnt;
+}
+
+int getMaxPid(void)
+{
+  struct proc *p;
+  acquire(&ptable.lock);
+  int max_pid = -1;
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)              
+  {
+    if (p->pid > max_pid)       //to calculate max pid
+      max_pid = (p->pid);
+  }
+  release(&ptable.lock);
+  return max_pid;
+}
+
+
+int getProcInfo(int pid, struct processInfo *pif)
+{
+  struct proc *p;
+  acquire(&ptable.lock);
+  int flag = -1;
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)        // it it matches the given id
+    {
+      pif->ppid = p->parent->pid;
+      pif->numberContextSwitches = p->count_contextswitch;
+      pif->psize = p->sz;
+      flag = 0;
+      break;
+    }
+  }
+  release(&ptable.lock);
+  return flag;
+}
+int set_burst_time(int bt)
+{
+  int flag = -1;
+  acquire(&ptable.lock);
+  mycpu()->proc->burst_time = bt;       // to set the burst time
+  flag = 0;
+  release(&ptable.lock);
+  yield();
+  return flag;
+}
+
+int get_burst_time()
+{
+  int burstTime = -1;
+  acquire(&ptable.lock);
+  burstTime = mycpu()->proc->burst_time;
+  release(&ptable.lock);
+  return burstTime;
+}
+int process_state()
+{
+  struct proc *p;
+  sti();
+  acquire(&ptable.lock);
+  cprintf("Name \t PID \t State \t Burst_Time \n");
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if(p->state == ZOMBIE)
+      cprintf("%s \t %d \t ZOMBIE \t %d \n ", p->name, p->pid, p->burst_time);
+    else if (p->state == RUNNABLE)
+      cprintf("%s \t %d \t RUNNABLE \t %d \n ", p->name, p->pid, p->burst_time);
+    else if (p->state == EMBRYO)
+      cprintf("%s \t %d \t EMBRYO \t %d \n ", p->name, p->pid, p->burst_time);
+    else if (p->state == RUNNING)
+      cprintf("%s \t %d \t RUNNING \t %d \n ", p->name, p->pid, p->burst_time);
+    else if (p->state == SLEEPING)
+      cprintf("%s \t %d \t SLEEPING \t %d \n ", p->name, p->pid, p->burst_time);
+  }
+  release(&ptable.lock);
+  return 0;
+}
diff -ruN xv6org/processInfo.h xv6/processInfo.h
--- xv6org/processInfo.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6/processInfo.h	2020-06-12 12:22:40.000000000 +0530
@@ -0,0 +1,6 @@
+struct processInfo
+{
+    int ppid;
+    int psize;
+    int numberContextSwitches;
+};
diff -ruN xv6org/process_state.c xv6/process_state.c
--- xv6org/process_state.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6/process_state.c	2020-10-14 12:29:55.262939000 +0530
@@ -0,0 +1,9 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fcntl.h"
+
+int main(void){
+  process_state();
+  exit();
+}
\ No newline at end of file
diff -ruN xv6org/proc.h xv6/proc.h
--- xv6org/proc.h	2020-08-10 23:58:02.000000000 +0530
+++ xv6/proc.h	2020-10-14 12:47:27.873251000 +0530
@@ -49,10 +49,7 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int count_contextswitch;     // Counter for Context Switches of the process
+  int burst_time;              // Burst Time for process
 };
 
-// Process memory is laid out contiguously, low addresses first:
-//   text
-//   original data and bss
-//   fixed-size stack
-//   expandable heap
Binary files xv6org/_ps and xv6/_ps differ
diff -ruN xv6org/syscall.c xv6/syscall.c
--- xv6org/syscall.c	2020-08-10 23:58:02.000000000 +0530
+++ xv6/syscall.c	2020-10-14 12:30:49.888794000 +0530
@@ -103,29 +103,41 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_getNumProc(void);
+extern int sys_getMaxPid(void);
+extern int sys_getProcInfo(void);
+extern int sys_set_burst_time(void);
+extern int sys_get_burst_time(void);
+extern int sys_process_state(void);
 
 static int (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
+    [SYS_fork] sys_fork,
+    [SYS_exit] sys_exit,
+    [SYS_wait] sys_wait,
+    [SYS_pipe] sys_pipe,
+    [SYS_read] sys_read,
+    [SYS_kill] sys_kill,
+    [SYS_exec] sys_exec,
+    [SYS_fstat] sys_fstat,
+    [SYS_chdir] sys_chdir,
+    [SYS_dup] sys_dup,
+    [SYS_getpid] sys_getpid,
+    [SYS_sbrk] sys_sbrk,
+    [SYS_sleep] sys_sleep,
+    [SYS_uptime] sys_uptime,
+    [SYS_open] sys_open,
+    [SYS_write] sys_write,
+    [SYS_mknod] sys_mknod,
+    [SYS_unlink] sys_unlink,
+    [SYS_link] sys_link,
+    [SYS_mkdir] sys_mkdir,
+    [SYS_close] sys_close,
+    [SYS_getNumProc] sys_getNumProc,
+    [SYS_getMaxPid] sys_getMaxPid,
+    [SYS_getProcInfo] sys_getProcInfo,
+    [SYS_set_burst_time] sys_set_burst_time,
+    [SYS_get_burst_time] sys_get_burst_time,
+    [SYS_process_state] sys_process_state,
 };
 
 void
diff -ruN xv6org/syscall.h xv6/syscall.h
--- xv6org/syscall.h	2020-08-10 23:58:02.000000000 +0530
+++ xv6/syscall.h	2020-10-14 12:15:49.195135000 +0530
@@ -20,3 +20,9 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_getNumProc 22
+#define SYS_getMaxPid 23
+#define SYS_getProcInfo 24
+#define SYS_set_burst_time 25
+#define SYS_get_burst_time 26
+#define SYS_process_state 27
\ No newline at end of file
diff -ruN xv6org/sysfile.c xv6/sysfile.c
--- xv6org/sysfile.c	2020-08-10 23:58:02.000000000 +0530
+++ xv6/sysfile.c	2020-09-23 23:32:54.000000000 +0530
@@ -15,7 +15,7 @@
 #include "sleeplock.h"
 #include "file.h"
 #include "fcntl.h"
-
+// #include<string.h>
 // Fetch the nth word-sized system call argument as a file descriptor
 // and return both the descriptor and the corresponding struct file.
 static int
@@ -442,3 +442,25 @@
   fd[1] = fd1;
   return 0;
 }
+int sys_wolfie(void)
+{
+  //Image of wolfie in ascii
+  char *wolf = "#############################################################\n###################################################   #######\n###############################################   /~\\   #####\n############################################   _- `~~~', ####\n##########################################  _-~       )  ####\n#######################################  _-~          |  ####\n####################################  _-~            ;  #####\n##########################  __---___-~              |   #####\n#######################   _~   ,,                  ;  `,,  ##\n#####################  _-~    ;'                  |  ,'  ; ##\n###################  _~      '                    `~'   ; ###\n############   __---;                                 ,' ####\n########   __~~  ___                                ,' ######\n#####  _-~~   -~~ _                               ,' ########\n##### `-_         _                              ; ##########\n#######  ~~----~~~   ;                          ; ###########\n#########  /          ;                        ; ############\n#######  /             ;                      ; #############\n#####  /                `                    ; ##############\n###  /                                      ; ###############\n#          ";
+  const int wolf_size = 1251; // Size of wolfie
+  void *buf; 
+  uint bufsize;
+  argptr(0, (void *)&buf, sizeof(*buf)); // Read buf from arguments using argptr
+  argptr(1, (void *)&bufsize, sizeof(bufsize)); // Read bufsize
+
+  if (bufsize < wolf_size) // Return -1 if cannot be copied
+    return -1;
+  else
+  {
+    for (int i = 0; i < wolf_size; i++)
+    {
+      ((char *)buf)[i] = (char)wolf[i]; // Copy character by character to buffer
+    }
+    return wolf_size;
+  }
+
+}
\ No newline at end of file
diff -ruN xv6org/sysproc.c xv6/sysproc.c
--- xv6org/sysproc.c	2020-08-10 23:58:02.000000000 +0530
+++ xv6/sysproc.c	2020-10-14 12:47:04.163240000 +0530
@@ -89,3 +89,43 @@
   release(&tickslock);
   return xticks;
 }
+
+// get max PID amongst the PIDs of all currently active processes in the system.
+int sys_getMaxPid(void){
+  return getMaxPid();      // call getMaxPid function
+}
+
+// get number of active processes in the system
+int sys_getNumProc(void){
+    return getNumProc();    // call getNumProc function
+}
+
+// gives info of the process
+int sys_getProcInfo(void){
+  int pid;
+  struct processInfo *pif;
+  int sz1 = sizeof(pid);
+  int sz2 = sizeof(pif);
+  argptr(0, (void *)&pid, sz1);        
+  argptr(1, (void *)&pif, sz2); 
+  return getProcInfo(pid, pif);     // call getProcInfo function
+}
+
+// set burst time of a process
+int sys_set_burst_time(void)
+{
+  int n;
+  int sz = sizeof(n);
+  argptr(0, (void *)&n, sz);
+  return set_burst_time(n);       // call set_burst_time function
+}
+
+// get burst time of a process
+int sys_get_burst_time(void){
+  return get_burst_time();        // call get_burst_time function
+}
+
+// get the state of the process
+int sys_process_state(void){
+  return process_state();         // call process_state function
+}
\ No newline at end of file
diff -ruN xv6org/testBurstTime.c xv6/testBurstTime.c
--- xv6org/testBurstTime.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6/testBurstTime.c	2020-10-14 12:50:56.804789000 +0530
@@ -0,0 +1,12 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main()
+{
+
+  printf(1 , "Burst Time before setting burst time: %d \n" , get_burst_time());
+  set_burst_time(15);
+  printf(1 , "Burst Time after setting burst time: %d \n" , get_burst_time());
+  exit();
+}
\ No newline at end of file
diff -ruN xv6org/test_sched.c xv6/test_sched.c
--- xv6org/test_sched.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6/test_sched.c	2020-10-15 15:18:39.593215000 +0530
@@ -0,0 +1,118 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "processInfo.h"
+#include "fcntl.h"
+
+// CPU bound process
+void
+random_computation()
+{
+    float a = 0, b=0;
+
+    while(b<1000000)
+    {
+        if((int)b%2 == 0)
+            a = a - (1.5*2.6);
+        else
+            a = a+ 1.6*4.9;
+        b+=1;
+    }
+}
+
+// I/O bound process
+void
+random_io()
+{
+    int i=150;
+    while(i--)
+    {
+        printf(1,"$");
+    }
+    sleep(3);
+    printf(1, "\n");
+}
+
+int 
+main(int argc, char *argv[])
+{
+
+
+    // This code is for test case 3 and 4.
+    // To run this code for test case 1, change random_computation to random_io in else block.
+    // To run this code for test case 2, change random_io to random_computation in else block.
+    int n;
+    n = atoi(argv[1]);
+    if (argc < 2) n=5;
+    int burst_time=0;
+    int pids[n];
+    int returnOrder[n];    // to store completiton order
+    int map[500];          // to map process id to child number
+    int rand_bt[20] = {20, 17, 1, 5, 13, 11, 4, 10, 6, 3, 3, 2, 18, 7, 8, 13, 17, 8, 19, 8};
+    int i=0;
+    while(i<n)
+    {
+        if(i==2 || i==4 || i==9 || i==14)
+        {
+            int id = fork();
+            if (id == 0)
+            {
+                burst_time = rand_bt[i];
+                set_burst_time(burst_time);
+                random_io();
+                exit();    
+            }
+            else if (id < 0)
+            {
+                printf(1, "Error!! Could not be forked. \n");
+                exit();
+            }
+            else
+            {
+                pids[i] = id;
+                map[id]=i;
+            }
+        }
+        else
+        {
+            int id = fork();
+            if (id == 0)
+            {
+                burst_time = rand_bt[i];
+                set_burst_time(burst_time);
+                random_io();
+                exit();    
+            }
+            else if (id < 0)
+            {
+                printf(1, "Error!! Could not be forked. \n");
+                exit();
+            }
+            else
+            {
+                pids[i] = id;
+                map[id]=i;
+            }
+        }
+        
+        i++;
+    }
+
+    for (int i = 0; i < n; i++)
+    {
+        returnOrder[i] = wait();
+    }
+    printf(1, "Child No.\tPID\t\t Burst Time     \n");
+    for (int i = 0; i < n; i++)
+    {
+        printf(1, "%d\t\t %d\t\t %d  \n", i+1, pids[i], rand_bt[i]);
+    }
+    printf(1, "\nCompletion Order: \n");
+    printf(1, "PID\t\t Burst Time     \n");
+    for (int i = 0; i < n; i++){
+        printf(1, "%d\t\t %d  \n", returnOrder[i], rand_bt[map[returnOrder[i]]]);
+        
+    }
+    exit();
+}
+
diff -ruN xv6org/test_scheduler.c xv6/test_scheduler.c
--- xv6org/test_scheduler.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6/test_scheduler.c	2020-10-15 15:14:59.375761000 +0530
@@ -0,0 +1,117 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "processInfo.h"
+#include "fcntl.h"
+
+// CPU bound process
+void
+random_computation()
+{
+    float a = 0, b=0;
+
+    while(b<1000000)
+    {
+        if((int)b%2 == 0)
+            a = a - (1.5*2.6);
+        else
+            a = a+ 1.6*4.9;
+        b+=1;
+    }
+}
+
+// I/O bound process
+void
+random_io()
+{
+    int i=150;
+    while(i--)
+    {
+        printf(1,"$");
+    }
+    sleep(3);
+    printf(1, "\n");
+}
+
+int 
+main(int argc, char *argv[])
+{
+
+
+    // This code is for test case 3 and 4.
+    // To run this code for test case 1, change random_computation to random_io in else block.
+    // To run this code for test case 2, change random_io to random_computation in else block.
+    int n;
+    n = atoi(argv[1]);
+    if (argc < 2) n=5;
+    int burst_time=0;
+    int pids[n];
+    int returnOrder[n];    // to store completiton order
+    int map[500];          // to map process id to child number
+    int rand_bt[20] = {20, 17, 1, 5, 13, 11, 4, 10, 6, 3, 3, 2, 18, 7, 8, 13, 17, 8, 19, 8};
+    int i=0;
+    while(i<n)
+    {
+        if(i==2 || i==4 || i==9 || i==14)
+        {
+            int id = fork();
+            if (id == 0)
+            {
+                burst_time = rand_bt[i];
+                set_burst_time(burst_time);
+                random_io();
+                exit();    
+            }
+            else if (id < 0)
+            {
+                printf(1, "Error!! Could not be forked. \n");
+                exit();
+            }
+            else
+            {
+                pids[i] = id;
+                map[id]=i;
+            }
+        }
+        else
+        {
+            int id = fork();
+            if (id == 0)
+            {
+                burst_time = rand_bt[i];
+                set_burst_time(burst_time);
+                random_computation();
+                exit();    
+            }
+            else if (id < 0)
+            {
+                printf(1, "Error!! Could not be forked. \n");
+                exit();
+            }
+            else
+            {
+                pids[i] = id;
+                map[id]=i;
+            }
+        }
+        
+        i++;
+    }
+
+    for (int i = 0; i < n; i++)
+    {
+        returnOrder[i] = wait();
+    }
+    printf(1, "Child No.\tPID\t\t Burst Time     \n");
+    for (int i = 0; i < n; i++)
+    {
+        printf(1, "%d\t\t %d\t\t %d  \n", i+1, pids[i], rand_bt[i]);
+    }
+    printf(1, "\nCompletion Order: \n");
+    printf(1, "PID\t\t Burst Time     \n");
+    for (int i = 0; i < n; i++){
+        printf(1, "%d\t\t %d  \n", returnOrder[i], rand_bt[map[returnOrder[i]]]);
+        
+    }
+    exit();
+}
diff -ruN xv6org/trap.c xv6/trap.c
--- xv6org/trap.c	2020-08-10 23:58:02.000000000 +0530
+++ xv6/trap.c	2020-10-15 13:07:58.696731000 +0530
@@ -102,9 +102,10 @@
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
+
+  // if(myproc() && myproc()->state == RUNNING &&
+  //    tf->trapno == T_IRQ0+IRQ_TIMER)
+  //   yield();
 
   // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
diff -ruN xv6org/user.h xv6/user.h
--- xv6org/user.h	2020-08-10 23:58:02.000000000 +0530
+++ xv6/user.h	2020-10-14 12:15:21.895463000 +0530
@@ -1,6 +1,6 @@
 struct stat;
 struct rtcdate;
-
+struct processInfo;
 // system calls
 int fork(void);
 int exit(void) __attribute__((noreturn));
@@ -37,3 +37,11 @@
 void* malloc(uint);
 void free(void*);
 int atoi(const char*);
+
+// Function declaration for the system call
+int getNumProc(void);
+int getMaxPid(void);
+int getProcInfo(int ,struct processInfo*);
+int set_burst_time(int);
+int get_burst_time(void);
+int process_state(void);
\ No newline at end of file
diff -ruN xv6org/usys.S xv6/usys.S
--- xv6org/usys.S	2020-08-10 23:58:02.000000000 +0530
+++ xv6/usys.S	2020-10-14 12:15:20.019485000 +0530
@@ -29,3 +29,9 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(getNumProc)
+SYSCALL(getMaxPid)
+SYSCALL(getProcInfo)
+SYSCALL(set_burst_time)
+SYSCALL(get_burst_time)
+SYSCALL(process_state)
\ No newline at end of file
